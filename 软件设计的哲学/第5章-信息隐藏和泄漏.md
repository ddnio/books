# 第5章：信息隐藏（和泄漏）

## 核心理念

**信息隐藏是实现深模块的最重要技术**。每个模块应该封装一些设计决策，这些决策嵌入在模块的实现中，但不出现在接口中。通过隐藏复杂性，我们可以创建简单的接口和强大的实现。

> **关键洞察**：信息隐藏不是简单地将变量设为private。真正的信息隐藏是隐藏设计决策、实现机制和复杂性，让模块的使用者不需要了解这些细节就能完成工作。

## 什么是信息隐藏？

### 错误理解 vs 正确理解

**❌ 常见误解：**
```java
public class User {
    private String name;     // 设为private就是信息隐藏？
    private String email;    // 错误！
    
    // getter/setter完全暴露了内部信息
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}
```

**✅ 真正的信息隐藏：**
```java
public class UserAccount {
    // 隐藏的信息：
    // - 用户数据如何存储
    // - 密码如何加密
    // - 会话如何管理
    // - 权限如何验证
    
    public void updateProfile(ProfileUpdate update) {
        // 调用者不需要知道更新涉及哪些字段
        // 不需要知道验证规则
        // 不需要知道存储细节
    }
    
    public boolean hasPermission(Permission permission) {
        // 隐藏了权限系统的复杂性
    }
}
```

## 应该隐藏什么信息？

### 1. 数据结构和算法

```java
// ❌ 暴露内部数据结构
public class SearchEngine {
    public HashMap<String, List<Document>> getIndex() {
        return invertedIndex;  // 暴露了使用倒排索引
    }
    
    public void addToIndex(String word, Document doc) {
        // 调用者需要理解索引结构
    }
}

// ✅ 隐藏实现细节
public class SearchEngine {
    public SearchResults search(String query) {
        // 隐藏了：
        // - 使用什么索引结构（倒排索引？后缀树？）
        // - 如何分词
        // - 如何排序结果
        // - 如何优化查询
    }
    
    public void indexDocument(Document document) {
        // 简单接口，隐藏索引过程
    }
}
```

### 2. 底层实现细节

```java
// ❌ 暴露存储细节
public class FileManager {
    public void writeBlocks(String file, byte[] data, int blockSize) {
        // 为什么调用者要关心块大小？
    }
    
    public byte[] readFromDisk(int cylinder, int track, int sector) {
        // 暴露了物理存储细节！
    }
}

// ✅ 提供合适的抽象
public class DocumentStore {
    public void save(String documentId, Document document) {
        // 隐藏了：
        // - 存储位置（本地？云端？）
        // - 存储格式（JSON？二进制？）
        // - 分块策略
        // - 压缩算法
    }
    
    public Optional<Document> load(String documentId) {
        // 简单清晰的接口
    }
}
```

### 3. 时序依赖（最容易犯的错误！）

**时序分解是信息泄漏的主要来源：**

```java
// ❌ 时序分解：暴露操作顺序
public class OrderProcessor {
    public void validateOrder(Order order) { }      // 步骤1
    public void checkInventory(Order order) { }     // 步骤2  
    public void reserveInventory(Order order) { }   // 步骤3
    public void processPayment(Order order) { }     // 步骤4
    public void updateInventory(Order order) { }    // 步骤5
    public void sendConfirmation(Order order) { }   // 步骤6
}

// 调用者必须知道正确的调用顺序！
processor.validateOrder(order);
processor.checkInventory(order);
processor.reserveInventory(order);
// 如果忘记某个步骤或顺序错误怎么办？

// ✅ 隐藏操作顺序
public class OrderService {
    public OrderResult processOrder(Order order) {
        // 内部按正确顺序执行所有步骤
        // 调用者不需要知道有哪些步骤
        // 不需要知道步骤的顺序
        // 一个方法完成所有工作
    }
}
```

### 4. 错误处理机制

```java
// ❌ 暴露过多内部异常
public class EmailService {
    public void sendEmail(Email email) throws 
        SMTPConnectionException,      // 暴露使用SMTP
        AuthenticationException,      // 暴露认证过程
        RateLimitException,          // 暴露限流机制
        TemplateNotFoundException,    // 暴露模板系统
        AttachmentTooLargeException { // 暴露附件处理
        // 调用者需要处理5种不同的异常
    }
}

// ✅ 简化错误模型
public class EmailService {
    public EmailResult sendEmail(Email email) {
        try {
            // 内部处理所有异常情况
            performSend(email);
            return EmailResult.success();
        } catch (Exception e) {
            // 转换为用户友好的错误
            return EmailResult.failure(getUserFriendlyMessage(e));
        }
    }
}
```

## 信息泄漏的常见形式

### 1. 过度暴露配置

```java
// ❌ 配置地狱
public class DatabaseConnectionPool {
    public void setInitialSize(int size) { }
    public void setMaxActive(int max) { }
    public void setMaxIdle(int max) { }
    public void setMinIdle(int min) { }
    public void setMaxWait(long wait) { }
    public void setValidationQuery(String query) { }
    public void setTestOnBorrow(boolean test) { }
    public void setTestOnReturn(boolean test) { }
    public void setTestWhileIdle(boolean test) { }
    public void setTimeBetweenEvictionRuns(long time) { }
    // 还有20个配置项...
}

// ✅ 智能默认值 + 配置预设
public class DatabaseConnectionPool {
    // 99%的用户使用这个
    public static ConnectionPool create(String url) {
        return create(url, PoolConfig.DEFAULT);
    }
    
    // 提供预设配置
    public static ConnectionPool create(String url, PoolConfig config) {
        // PoolConfig.DEFAULT - 适合大多数应用
        // PoolConfig.HIGH_PERFORMANCE - 高并发场景
        // PoolConfig.DEVELOPMENT - 开发环境
    }
}
```

### 2. 泄漏实现选择

```java
// ❌ 类名泄漏实现
public class BubbleSortAlgorithm { }      // 暴露使用冒泡排序
public class MySQLUserRepository { }      // 暴露使用MySQL
public class RedisSessionStore { }        // 暴露使用Redis

// ✅ 隐藏实现选择
public class SortingService { }          // 内部可能用任何算法
public class UserRepository { }          // 内部可能用任何数据库
public class SessionStore { }            // 内部可能用任何存储
```

### 3. API设计中的信息泄漏

```java
// ❌ API暴露内部结构
public interface FileSystem {
    Inode getInode(int inodeNumber);
    Block readBlock(int blockNumber);
    void updateBlockMap(int file, int[] blocks);
}

// ✅ 提供用户视角的API
public interface FileSystem {
    void writeFile(String path, byte[] content);
    byte[] readFile(String path);
    void deleteFile(String path);
}
```

## 部分信息隐藏

有时完全隐藏信息是不现实的，但我们仍然可以为常见情况提供简单接口：

```java
public class HttpClient {
    // 90%的用户：超简单
    public String get(String url) {
        return request(url, Method.GET, defaultOptions());
    }
    
    // 9%的用户：常见定制
    public String get(String url, RequestOptions options) {
        return request(url, Method.GET, options);
    }
    
    // 1%的用户：完全控制
    public Response request(Request request) {
        // 完全定制化的请求
    }
    
    private RequestOptions defaultOptions() {
        return RequestOptions.builder()
            .timeout(5000)
            .retries(3)
            .followRedirects(true)
            .acceptCompression(true)
            .build();
    }
}
```

## 信息隐藏的最佳实践

### 1. 设计接口时的检查清单

```java
// 每次设计公共接口时，问自己：
// □ 如果实现完全改变，接口需要改变吗？
// □ 调用者真的需要知道这个细节吗？
// □ 这个参数对于常见用例是必需的吗？
// □ 能否通过智能默认值简化接口？
// □ 错误处理是否过于复杂？
```

### 2. 逐步改进示例

```java
// 版本1：初始设计（信息泄漏严重）
public class ReportGenerator {
    public void connectToDatabase(String url, String user, String pass) { }
    public ResultSet executeQuery(String sql) { }
    public List<Row> fetchRows(ResultSet rs) { }
    public String formatAsHTML(List<Row> rows, String template) { }
    public void writeToFile(String html, String filename) { }
}

// 版本2：隐藏实现步骤
public class ReportGenerator {
    public void generateReport(ReportRequest request, String outputFile) {
        // 隐藏了所有中间步骤
    }
}

// 版本3：更高层的抽象
public class ReportService {
    public Report generate(ReportSpecification spec) {
        // 返回Report对象，让调用者决定如何处理
    }
}
```

### 3. 类内部的信息隐藏

```java
public class OrderManager {
    // 即使在类内部，也要隐藏信息
    
    private OrderValidator validator;
    private PriceCalculator calculator;
    private InventoryService inventory;
    
    public OrderResult placeOrder(OrderRequest request) {
        // 公共方法：隐藏内部协作
        if (!validator.isValid(request)) {
            return OrderResult.invalid();
        }
        
        Price totalPrice = calculator.calculate(request);
        if (!inventory.reserve(request.getItems())) {
            return OrderResult.insufficientStock();
        }
        
        return createOrder(request, totalPrice);
    }
    
    // 私有方法也要隐藏复杂性
    private OrderResult createOrder(OrderRequest request, Price price) {
        // 每个私有方法负责一个明确的职责
        // 隐藏具体的实现细节
    }
}
```

## 何时不应该隐藏信息

### 必须暴露的信息

```java
public class PerformanceCriticalService {
    // 这些信息必须暴露，因为调用者需要做出明智的决策
    
    public void process(Data data, ProcessingOptions options) {
        // options包含：
        // - 并行度（影响资源使用）
        // - 内存限制（防止OOM）
        // - 超时设置（避免无限等待）
    }
    
    public ProcessingStats getStatistics() {
        // 性能监控需要的信息必须暴露
    }
}
```

## 总结

信息隐藏是创建深模块的关键技术。通过隐藏实现细节、设计决策和复杂性，我们可以：

1. **简化接口**：减少认知负担
2. **提高可维护性**：修改不影响用户
3. **增强模块深度**：简单接口+强大功能

**核心原则**：
- 隐藏"如何做"，暴露"做什么"
- 避免时序分解
- 为常见情况提供简单接口
- 只暴露必要的信息

**实践要点**：
- 每个模块封装一到几个设计决策
- 接口应该反映用户视角，而非实现视角
- 通过部分信息隐藏支持高级用例
- 在类内部也要应用信息隐藏

**下一步**：第6章将讨论如何设计通用模块，这是另一种创建深模块的技术。

---

> "最好的模块是那些提供强大功能却只需要简单接口的模块。信息隐藏是实现这一目标的关键。" —— David Parnas 